\chapter{Background} % 10-20 pages
\begin{comment}
This should form the bulk of the interim report. You should consider that your objective here is to produce a near final version of the background section, as it will appear in your final report.  All of this material should be re-usable, so it is worth getting it right at this stage of the project.  The details of what to include can be found in the Project Report guidelines.

From the Project Report guidelines:
The background section of the report should set the project into context by relating it to existing published work which you read at the start of the project when your approach and methods were being considered. There are usually many ways of solving a given problem, and you shouldn't just pick one at random. Describe and evaluate as many alternative approaches as possible. The published work may be in the form of research papers found in the academic literature, articles, text books, technical manuals, or even existing software or hardware of which you have had hands-on experience. You must acknowledge the sources of your inspiration. You are expected to have seen and thought about other people's ideas; your contribution will be putting them into practice in some other context. However, avoid plagiarism: if you take another person's work as your own and do not cite your sources of information/inspiration you are being dishonest. When referring to other pieces of work, cite the sources where they are referred to or used, rather than just listing them at the end. Accidental plagiarism or not knowing how to cite and reference is not a valid reason for plagiarism. Make sure you read and digest the Department's plagiarism document .

In writing the Background chapter you must demonstrate your ability to *analyse*, *synthesise* and *apply critical* judgement. Analysis is shown by explaining how the proposed solution operates in your own words as well as its benefits and consequences. Synthesis is shown through the organisation of your Related Work section and through identifying and generalising common aspects across different solutions. Critical judgement is shown by discussing the limitations of the solutions proposed both in terms of their disadvantages and limits of applicability.

Typically you can look for Background work using different search engines including:
* Google Scholar
* IEEExplore
* ACM Digital Library
* Citeseer
* Science Direct

**Note 1:** Often the terms *Background, Literature Review, Related Work* and *State of the Art* are used interchangeably.
**Note 2**: Keyword search is wonderful, but you need the right *Keywords*.
**Note 3:** IEEExplore, ACM Digital Library and Science Direct may require you to be on the College network to download the PDF versions of papers. If at home, use VPN.
\end{comment}

\section{Crash course}
\subsection{Category theory}
\subsubsection{Categories}
\subsubsection{Functors}
\subsubsection{Natural transformations}
\subsubsection{Adjunctions}
\todo{Add more information between here}
\subsubsection{Graded Monads}

\subsection{Relational algebra}
\todo{Add citation to the database book}
\subsubsection{Projections}
\subsubsection{Selections}
\subsubsection{Products}
\subsubsection{Joins}

\subsection{Evolution of database representation}
\subsubsection{Bags}
\todo{Understand and distinguish between bags being the bulk type}
\paragraph{Characteristics of a database}We expect our database approximation to not be ordered and admit multiplicities and a finite bag of values is one of the simplest constructions that does so. Like a finite set, a bag contains a collection of unordered values. However, unlike a set, bags can contain duplicate elements. \cite{RelationalAlgebraByWayOfAdjunctions} This multiplicty is key for processing non-idempotent aggregations. For instance, if summing up the ages of a database of people, without admitting multiplicty we would only sum each unique age once.
\subparagraph{Generalisation}Furthermore, going forward we generalise to bags of any types instead of the classical ``bags of records''. This also allows us to deal with intermediate tables that contain non-record values.
\todo{Add the mathematical parts about bags}
\todo{When reading about fininte maps it says that it's better for databases as non finite maps cannot be aggreagated, can non finite bags be aggreagates - is this why they are finite?}

\subsubsection{Indexed tables}
We want to move towards an indexed representation of our table in order to equijoin by indexing. \todo{Understand if this is right and equijoin by indexing}. So in this section we introduce the mathematical concepts required to define such an implementation.
\theoremstyle{definition}\newtheorem*{psetdef}{Pointed set}
\theoremstyle{definition}\newtheorem*{ppfuncdef}{Point-preserving function}
\theoremstyle{definition}\newtheorem*{mapdef}{Map}
\theoremstyle{definition}\newtheorem*{finitemapdef}{Finite map}
\begin{psetdef}\label{def:pset}
  A pointed set $\pset{A}{a}$ is a set $A$ with a distinguished element $a \in A$.
\end{psetdef}
We commonly refer to the distinguished element of a set $A$ as $null_A$ or, when not ambiguous to do so, $null$.
\begin{ppfuncdef}\label{def:ppfunc}
  Given two pointed sets $\pset{A}{null_A}$ and $\pset{B}{null_B}$, a total function $f: A \rightarrow B$ is point-preserving if $f(null_A) = null_B$.
\end{ppfuncdef}
\todo{See if there is a way to have better spacing in brackets}

\todo{Add in more mathematical detail for point preserving functions}

We now have the mathematical tools required to define a map. In its finite form a map is widely known in computer science by many other names such as a dictionary, association lists or key-value maps.

Let $\keyset$ be a set and $\valset$ a pointed set. To those already familiar with maps, it may help to think of $\keyset$ as keys and $\valset$ as values.
\begin{mapdef}
  A map of type $\map{\keyset}{\valset}$ is a total 
\end{mapdef}
\todo{Introduced indexed tables}

\section{Literature Review}
\subsection{Benchmarking databases}
\subsection{Expanding the use of adjunctions}
\subsection{Evolution of database representation}
\subsubsection{Bags}
\todo{Understand and distinguish between bags being the bulk type}
\paragraph{Characteristics of a database}We expect our database approximation to not be ordered and admit multiplicities and a finite bag of values is one of the simplest constructions that does so. Like a finite set, a bag contains a collection of unordered values. However, unlike a set, bags can contain duplicate elements. \cite{RelationalAlgebraByWayOfAdjunctions} This multiplicity is key for processing non-idempotent aggregations. For instance, if summing up the ages of a database of people, without admitting multiplicity we would only sum each unique age once.
\subparagraph{Generalisation}Furthermore, going forward we generalise to bags of any types instead of the classical ``bags of records''. This also allows us to deal with intermediate tables that contain non-record values.
\todo{Add the mathematical parts about bags}
\todo{When reading about finite maps it says that it's better for databases as non finite maps cannot be aggregated, can non finite bags be aggregates - is this why they are finite?}

\subsubsection{Indexed tables}
We want to move towards an indexed representation of our table in order to equijoin by indexing. \todo{Understand if this is right and equijoin by indexing}. So in this section we introduce the mathematical concepts required to define such an implementation.
\theoremstyle{definition}\newtheorem*{psetdef}{Pointed set}
\theoremstyle{definition}\newtheorem*{ppfuncdef}{Point-preserving function}
\theoremstyle{definition}\newtheorem*{mapdef}{Map}
\theoremstyle{definition}\newtheorem*{finitemapdef}{Finite map}
\begin{psetdef}\label{def:pset}
  A pointed set $\pset{A}{a}$ is a set $A$ with a distinguished element $a \in A$.
\end{psetdef}
We commonly refer to the distinguished element of a set $A$ as $null_A$ or, when not ambiguous to do so, $null$.
\begin{ppfuncdef}\label{def:ppfunc}
  Given two pointed sets $\pset{A}{null_A}$ and $\pset{B}{null_B}$, a total function $f: A \rightarrow B$ is point-preserving if $f(null_A) = null_B$.
\end{ppfuncdef}
\todo{See if there is a way to have better spacing in brackets}

\todo{Add in more mathematical detail for point preserving functions}

We now have the mathematical tools required to define a map. In its finite form a map is widely known in computer science by many other names such as a dictionary, association lists or key-value maps.

Let $\keyset$ be a set and $\valset$ a pointed set. To those already familiar with maps, it may help to think of $\keyset$ as keys and $\valset$ as values.
\begin{mapdef}
  A map of type $\map{\keyset}{\valset}$ is a total function from K to V.
\end{mapdef}
\begin{finitemapdef}
  A finite map of type \finitemap{\keyset}{\valset} is a map where only a finite number of keys are mapped to $null_\valset$ (where $null_\valset$ is the distinguished element of \valset). 
\end{finitemapdef}
The advantage of using a finite map in a database is to allow aggregation.
\todo{Understand why only semi-monoidal}
\todo{Introduced indexed tables}
\chapter{Project Plan} % 1-2 pages
\begin{comment}
You should explain what needs to be done in order to complete the project and roughly what you expect the timetable to be. Don’t forget to include the project write-up (the final report), as this is a major part of the exercise. It’s important to identify key milestones and also fall-back positions, in case you run out of time.  You should also identify what extensions could be added if time permits.  The plan should be complete and should include those parts that you have already addressed (make it clear how far you have progressed at the time of writing).  This material will *not* appear in the final report.
\end{comment}

The project has a clear starting point and a wide range of potential branches to eventually explore. This allows the project to venture down many different specific roots, ranging in application focused to theoretically based.
We outline the stages the project can take below.

\section{Initial research and literature review}\label{sec:researchstage}
As the project could eventually take a turn into the theoretical side of the paper \cite{RelationalAlgebraByWayOfAdjunctions} this part is crucial. The time frame for this will be ongoing and has started, however the bulk should be finished by the end of January. An intuition as well as knowledge of the applications of category theory in the wider range of computer science would be vital in order to spot potential improvements in any results found while implementing and benchmarking the findings of the base paper \cite{RelationalAlgebraByWayOfAdjunctions} .

I do expect, however, that there would be a period of time after finishing \fref{sec:implementation} to return to this step in more detail than normal in order to fully solidify the direction of the project.

Of course research is also important to create a fair and rigorous benchmarking system. This style of research should be concluded in the coming days in order to ensure that any implementation is built to play nicely with the tools to be used (and potentially initially specifically for the datasets chosen).
\section{Implementation of the differing equijoin algorithms}\label{sec:implementation}
After understanding the basics of the theoretical implications as well as how category theory underpins Haskell as whole, work can be started on the first tangible step. That is to implement a mini database system that can query a given dataset, both using the inefficient and efficient equijoins.
\subsection{Implementation}
Initially the implementation will be very tailored to the data sources chosen. This will be done to avoid the difficulties of generalising types and creating a coherent system under Haskell's strict rules. It is not too difficult or even out of the scope of the project, but I feel as though focusing on the results of benchmarking will be more efficient in earlier stages. I hope to get this done by the end of February.
\subsection{Evaluation and analysis}
The analysis should begin as soon as the implementation has been completed. At the very least, benchmarking seems to be quite heuristic and experience helps a lot, thus some time should be used to make sure that the results are as accurate as possible. At this stage, if experience has suggested that changing the implementation would not be too much effort, I might also consider changing the data source the tests were based on in order to deal with more interesting or accurate results if any issues seem to emerge. This process should hopefully take a couple weeks.

Evaluation, however, should be done as an ongoing process during the project. A plan to evaluate will be presented in \fref{sec:correctnessevaluation}.

\section{Theoretical analysis of the remaining relational algebra}\label{sec:theoreticalanalysis}
After the implementation of the findings of the paper, I hope to have gained a much deeper understanding of the practicalities of database querying. This along with the mathematical intuition I hope to have gained during the stage described \fref{sec:researchstage} would inspire thought to which other operations currently do not adhere to a monadic structure or efficient implementations. Of course this would be greatly aided by research in the large field of database queries, potentially choosing to describe already known optimisations using this new model and adjunctions instead. This section of the project could last until new work is no longer being found.
\section{Reporting the project}
% Report due Monday 19 June 2022
Reporting the project is a necessity. My project is unique in that the first section is itself an analysis and therefore, if done correctly, will almost immediately be written in a final report style while it is being conducted. Later parts of the project might need their own time set apart to write about as mathematics is rarely linear and the report should tell a compelling story.

My plan is to continue to develop the tools to efficiently write my report alongside the implementation of the database, and begin to draft and validate the final parts of the report a month before the deadline. Useful tools I have already integrated are both manual and commit triggered checks on the spelling and code style of the reports. I have also worked on automatic releases and management of different report versions, early in December. A few of the systems are helpful but not at their potential yet and so I might put some time to think about possible extensions, for instance custom dictionaries for the spell checker so it does not flag up domain specific terminology as errors. I definitely need to migrate the report structure I have to lhs2\TeX{} so that when I have code snippets to report it can be done with ease. This should be finished by February, in time to develop the database in the report if that is the workflow I find most beneficial.

\section{Application of methods to other domains}
After enough theoretical knowledge is obtained in the research and implementation stages, thought can be given about how to extend the line of reasoning and techniques used in the paper in order apply them in different domains with these so-called bulk types.
\subsection{Logic programming}
It is clear that programs themselves can be thought of as a bulk type. Especially purely declarative languages such as \emph{ASP} where the order of clauses does not matter, a view of the program as a bulk type could easily fall to sugared version of a bag. A roadmap could change depending on how promising the results are; an initial investigation could be made into \emph{definite logic programs}. We could apply this analysis of bulk types both on the programs themselves and their answer sets. The investigation could expand to extensions of the language, notable \emph{negation-by-failure} where more complex behaviours are seen. I do not see the project extending defining syntax past \emph{normal logic programming} due to the increasing complexity.
\section{Possible extensions}
\subsection{Progress in optimising other aspects of relational algebra}
Given a successful stage in \fref{sec:theoreticalanalysis} this might give the project a lot of scope to grow as an extension over the final months. I could choose between using the category theory learned to write proofs of the theoretical advantage of any novel approach I think of, or just a novel description of what is already there. Alternatively I could extend my implementation to include the modified operations and do another analysis of their practical performance change.
\subsection{A full implementation}
If I choose to take this project down a more practical root, a full general implementation of the database system implemented could be made as an extension. This would allow a specific schema and interface with the data stored in Haskell's data structures itself, differing from database abstraction layers that communicate to SQL servers currently used in production.\cite{HDBC} Although this extension would not be production ready, I hope that it would be demonstrative on whether list comprehensions have a place among relational calculus, both by its viability to be implemented but also developer satisfaction using them.
\subsection{Applications of related fields to relational calculus}
Category theory is extremely general and has countless applications in computer science, from describing lambda calculi to describing type systems.\cite{BasicCategoryTheoryforCS} A particularly interesting paper about modelling concurrency \cite{CategoriesForModellingConcurrency} caught my eye as a topic to research into in the future, given how vital concurrency is to database management systems \cite{DatabaseSystems}.

Research could also be done into the viability of modelling mutating behaviours via referential calculus, that either change schema or components.

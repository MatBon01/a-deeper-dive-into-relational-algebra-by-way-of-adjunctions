\section{Synthetic database creation}\label{sec:benchmark:database}
Synthetic databases are critical to running a customisable and repeatable
benchmark. Those who wish to benchmark a database can use custom synthetic
databases in order to specify a large amount of unknowns in the data of the
benchmarks run. Examples of such parameters range from both the size of the
database as a whole to on a tuple level by carefully choosing attribute domains.
Attribute domains can also help give a heuristic control to resource load while
processing queries by determining how difficult it is to computer an answer (for
instance using the equality of strings). Furthermore, when designed correctly synthetic
databases can provide a readable method to easily specify wanted properties of
queries via explicit and easy to calculate selectivity factors in selections and
joins. More information on database benchmark design can be found in
\fref{sec:background:benchmarkbestpractices}.

\paragraph{} In order to have a customisable synthetic benchmark for the
project, we created a collection of python modules to easily configure and
export different databases. We chose to implement this as an extensible set of
classes to represent different cell domains which then can be configured,
specified and passed to objects representing larger structures of the database
and handle generation for each of their responsibilities. This section is a
walk through the ensuing python modules and their internal relationships.

\begin{figure}[t]
\begin{tikzpicture}
    \begin{package}{databasegen}
        \begin{abstractclass}{Cell}{0,0}
            \operation[0]{+ generate() : str}
        \end{abstractclass}

        \begin{class}{RecordGenerator}{7, 0}
            \attribute{+ cells : List[Cell]}
            \operation{+ generate() : List[str]}
        \end{class}

        \begin{class}{TableGenerator}{0, -3}
            \attribute{+ record\_generator : RecordGenerator}
            \operation{+ generate(num\_records : int = 1) : Iterable[List[str]]}
        \end{class}

        \begin{class}{CSVTableGenerator}{7, -3}
            \attribute{+ path : str}
            \attribute{+ dialect : str}
            \attribute{+ table\_generator : TableGenerator}
            \operation{+ generate(num\_records : int) : null}
        \end{class}

        \composition{RecordGenerator}{}{}{Cell}
        \composition{TableGenerator}{}{}{RecordGenerator}
        \composition{CSVTableGenerator}{}{}{TableGenerator}
    \end{package}
\end{tikzpicture}
\caption{UML class diagram showing the modules used for synthetic database
creation.}
\label{fig:project:benchmark:creation-class-diagram}
\end{figure}

\paragraph{Overview} This section describes the overall structure of the
solution, a class-diagram to aid the explanation can be found in
\fref{fig:project:benchmark:creation-class-diagram}.
We start with a list of objects extending the \lstinline{Cell}
abstract class. We pass this list to a \lstinline{RecordGenerator} object, which
then can be given to a \lstinline{TableGenerator} object to generate the
database. Finally the database generator can be given to an object, such as the
implemented \lstinline{CSVTableGenerator} to create the
specified output. The advantages of this approach is the ability to easily
configure a handful of properties of the output database by varying just the list of cells.
Cells can be easily manipulated given they conform to the \lstinline{Cell} API
and so their basic capabilities cover a large amount of behaviour and
compositions.

\paragraph{Cell} The \lstinline{Cell} abstract class presents the main API for
customising the domain of attributes in a database table. It defines only one
operation, namely \lstinline{generate() : str} which returns the next value of
the attribute the \lstinline{Cell} class represents. It is worth noting that
once you extend the \lstinline{Cell} abstract class, its method is not static so
an object must be instantiated; this gives every attribute the ability to hold
state to help control the generation of values.

In practice, when extending the cell class for uses within the project, specific
patterns would emerge. Usually, most cells require a
\lstinline{Random} object in their initialiser. The benefit to the composition
with an external \lstinline{Random} object is that the generation of values can
be controlled both in a fine-tuned and systematic way; this allows the user to
specify the distribution used to generate numbers both in a cell scope and
interlink randomness between cells by sharing \lstinline{Random} objects.
Although \lstinline{Cell} is an abstract class, I did not think it would be
appropriate to enforce the use of a \lstinline{Random} object in the initialiser
or give default behaviours. The result of generating a cell can be so varied
that no default behaviour would be appropriate in a general case, potentially
causing future extensions of the \lstinline{Cell} class to behave unexpectedly.
Furthermore, unfortunately python does not support interfaces and favours duck
typing and so abstract classes were a necessary evil to specify a common API and
type the code for static analysis; otherwise an interface would much better suit
the problem domain. As a final addition, abstract classes with behaviour
increases the coupling of the code and so the argument could be made it would
negatively impact the cleanliness of the code.

In order to create the joinbench benchmark a handful of different cells were
designed to represent the domains necessary to create the \relation{JOINBENCH}
table. Great care was taken in the design to eliminate duplication and
generalise the cells as will be presented here.

\paragraph{RecordGenerator} The \lstinline{RecordGenerator} class is
responsible for defining objects that generate the tuples of a table. As a tuple
is a set of attributes, the \lstinline{RecordGenerator} must be instantiated
with a list of \lstinline{Cell}s. Note that in this implementation the set of
attributes as theoretically outlined in \fref{sec:relationalmodel} gain an
order but this is for the obvious pragmatic use when exporting data. The
\lstinline{RecordGenerator} class defines only one operation,
\lstinline{generate}, but instead of returning a string, it returns a list of
strings in the same order as the list of \lstinline{Cell}s passed to the
constructor.

\paragraph{TableGenerator} The \lstinline{TableGenerator} builds on the
\lstinline{RecordGenerator} in much the same way a table is a set of tuples. It
requires a \lstinline{RecordGenerator} in its constructor to define the domain
and number of attributes and also has a consistently named operation,
\lstinline{generate}. The operation \lstinline{generate} however is subtly
different from the pattern established in \lstinline{RecordGenerator}. Assuming
a table in practice should at least an order of magnitude larger than a single
tuple, it might become costly to generate the entire table at once and hold it
in memory while it is being used. Instead, the \lstinline{TableGenerator}'s
\lstinline{generate} function takes in a parameter describing how many rows to
generate, as one might expect, but returns an \lstinline{Iterable} type where
each iteration returns the list of strings generated by the
\lstinline{RecordGenerator}.

\paragraph{Outputting the data} Although there is no need for a next step,
outputting the data is likely to be a next step. After defining a
\lstinline{TableGenerator} we are left with an function that given the
cardinality of a relation, will product an iterator that generates such a table.
A recommended pattern for outputting data is again to take the
\lstinline{TableGenerator} as an argument during construction and define a
\lstinline{generate} function that specifies a number of records and returns
nothing. This counter intuitive return value is to ensure that the efficiency
gained by the \lstinline{TableGenerator} is not lost as accumulating the table
would cause, where possible it would be beneficial to write the relation one
tuple at a time to whatever output is desired. I did not define an interface as
think that this step in the process is closest to client code and is not needed
by framework outlined therefore it would be needlessly restrictive.
\subparagraph{CSVTableGenerator} An example of such a class used in the project
is the \lstinline{CSVTableGenerator} that follows the exact recommendations
above. It takes a specification of the CSV file to write to, namely a path and
CSV dialect, and generate commands the CSV library to write each record one row
at a time. Of course the operating system may buffer the output but at a high
level this allows for what I believe to fine-grained yet logical writes that the
operating system can schedule.
\subparagraph{Other ideas} There are many other way to potentially output the
data in useful ways. For instance, one may output the database to the standard
output
stream (or perhaps both standard output and a given file). More interestingly one could execute an SQL \lstinline{INSERT}
statement for each tuple, populating a running database.

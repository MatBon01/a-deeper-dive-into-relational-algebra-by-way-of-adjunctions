\section{Implementation}
We structure our implementation as a library, usually a file in a \texttt{Data}
module per data structure. We base a lot of the content on an example
implementation given in
\cite{RelationalAlgebraByWayOfAdjunctionsPrototypeImplementation}.
\todo{Write what I contributed}

\subsection{Pointed sets}
This section describes the types that declare instances of the
\texttt{PointedSet} type class.

For testing purposes, the most useful type to declare an instance of
\texttt{PointedSet} was the \texttt{Maybe} type. This fits very well as it can
easily raise any existing type to one with a distinguished element (null),
namely \texttt{Nothing}.

Another key type to declare an instance of \texttt{PointedSet} was the
\texttt{Bag} type. A key design decision here was to define \texttt{isEmpty}
using pattern matching in order to avoid the \texttt{Eq} constraint on the
container type of the Bag (i.e. \texttt{Eq a => Bag a}). This instance is key
for the indexing operation $ix$. The function $ix$ has a type $ix ::
\bag{(k, v)} \to \map{k}{(\bag{v})}$, coupled with the requirement $(Pointed v)
=> \map{k}{v}$ the necessity of the implementaion becomes clear and it is
important to note that when indexing the bag of key-value pairs, if a key has no
value, it is the "null" value for \texttt{Bag} that is used and not for $v$
(given that $v$ is even a \texttt{PointedSet} which is not required).

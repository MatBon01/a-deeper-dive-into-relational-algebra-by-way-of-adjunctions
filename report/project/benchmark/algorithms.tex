\section{Algorithms to benchmark}
In this section we present an overview of the three different algorithms we will
be comparing in this benchmark. The paper \relalg{} presents a solution for
equijoin (and arbitrary selections followed by joins) query optimisation using
structures in Haskell, the algorithms compared will comprise of two alternative
``dummy'' solutions which may be seen as a simple implementation without the
findings of the paper, and a solution using an indexed structure as described
in the paper.

\paragraph{Modular product} The first algorithm to be presented has been dubbed \modularproduct{}. This name
highlights the modular nature of the equijoin query (each part is expressesd in
discrete steps) while telling us that we are using the non-indexed approach of taking the
cartesian product. The \modularproduct{} class of algorithms use the
\lstinline[language=Haskell]{productEquijoin} funciton. As outlined above the
\lstinline[language=Haskell]{productEquijoin} works in two discrete steps, we
expect the function to compute the product of the two relations and then filter
based on the equijoin criteria as demonstrated by the following code.

\input{code/productEquijoin}

\noindent
The two discrete steps are clearly visible and separated by the composition of
functions. The first step is to computer the cartesian product using the
\lstinline[language=Haskell]{cp} function. As a reminder the {cp} function has
the following type signature.
\input{code/cpTypeSignature}

\noindent
The \lstinline[language=Haskell]{cp} function simply takes a pair of bags and
returns a bag constituting the pairs of elements as would be expected of the
cartesian product. The second step is to select the elements from the pair of
bags. The type signature of \lstinline[language=Haskell]{select} is as follows.
\input{code/selectTypeSignature}

\noindent
As you can see, \lstinline[language=Haskell]{select} is simply a
\lstinline[language=Haskell]{filter} on bags. The complexity arrives in the
equality function. The equality function is modified to transform the bags using
the given functions before comparison. This is to generalise the idea of
comparing certain attributes; as mentioned in \fref{sec:relationalmodel} an
equijoin is a join based on equality of certain attributes and therefore just as
a record would need a transformation to compare attribute, we arbitrarily
transform the bag.

\paragraph{old comprehension} The second of the `dummy' algorithms has been
dubbed \oldcomprehension{}. The old in the name comes, again, from the fact that
it does not make use of the indexed structures implemented and presented. It is
clear that the function will just name a list comprehension. We expect this
comprehension to take an element from both bags and, if the predicates required
by the equijoin are satisfied, form a pair. The following code demonstrates
this.

\input{code/comprehensionEquijoin.tex}

\noindent
As is to be expected, the previous code takes the form of a monad comprehension.
This is possible using the GHC extensions \verb|MonadComprehensions| and allowed by
the fact that \lstinline[language=Haskell]{Bag} is a monad. We see many similar
features to the \modularproduct{} algorithm. A major difference is that there is
no explicit product operations but the pair is created manually when a matching
pair is found (however, all pairs are still considered). The equality, though
not named in a function, also includes the transformation described above.

\section{Algorithms to benchmark}
In this section we present an overview of the three different algorithms we will
be comparing in this benchmark. The paper \relalg{} presents a solution for
equijoin (and arbitrary selections followed by joins) query optimisation using
structures in Haskell, the algorithms compared will comprise of two alternative
``dummy'' solutions which may be seen as a simple implementation without the
findings of the paper, and a solution using an indexed structure as described
in the paper.

\paragraph{Modular product} The first algorithm to be presented has been dubbed \modularproduct{}. This name
highlights the modular nature of the equijoin query (each part is expressesd in
discrete steps) while telling us that we are using the non-indexed approach of taking the
cartesian product. The \modularproduct{} class of algorithms use the
\lstinline[language=Haskell]{productEquijoin} funciton. As outlined above the
\lstinline[language=Haskell]{productEquijoin} works in two discrete steps, we
expect the function to compute the product of the two relations and then filter
based on the equijoin criteria as demonstrated by the following code.

\input{code/productEquijoin}

\noindent
The two discrete steps are clearly visible and separated by the composition of
functions. The first step is to computer the cartesian product using the
\lstinline[language=Haskell]{cp} function. As a reminder the {cp} function has
the following type signature.
\input{code/cpTypeSignature}

\noindent
The \lstinline[language=Haskell]{cp} function simply takes a pair of bags and
returns a bag constituting the pairs of elements as would be expected of the
cartesian product. The second step is to select the elements from the pair of
bags. The type signature of \lstinline[language=Haskell]{select} is as follows.
\input{code/selectTypeSignature}

\noindent
As you can see, \lstinline[language=Haskell]{select} is simply a
\lstinline[language=Haskell]{filter} on bags. The complexity arrives in the
equality function. The equality function is modified to transform the bags using
the given functions before comparison. This is to generalise the idea of
comparing certain attributes; as mentioned in \fref{sec:relationalmodel} an
equijoin is a join based on equality of certain attributes and therefore just as
a record would need a transformation to compare attribute, we arbitrarily
transform the bag.

\paragraph{old comprehension} The second of the `dummy' algorithms has been
dubbed \oldcomprehension{}. The old in the name comes, again, from the fact that
it does not make use of the indexed structures implemented and presented. It is
clear that the function will just name a list comprehension. We expect this
comprehension to take an element from both bags and, if the predicates required
by the equijoin are satisfied, form a pair. The following code demonstrates
this.

\input{code/comprehensionEquijoin.tex}

\noindent
As is to be expected, the previous code takes the form of a monad comprehension.
This is possible using the GHC extension \verb|MonadComprehensions| and allowed by
the fact that \lstinline[language=Haskell]{Bag} is a monad. We see many similar
features to the \modularproduct{} algorithm. A major difference is that there is
no explicit product operations but the pair is created manually when a matching
pair is found (however, all pairs are still considered). The equality, though
not named in a function, also includes the transformation described above.

\paragraph{Modular indexed} The final algorithm is the only of the three to use
indexing. The indexing tested in this benchmark is basic however and further
optimisations are not considered, hence the name `modular' as a query engine or
customised query writing could easily tune the idea. This algorithm is by far
the most complex and is a version of what is proposed in the paper \relalg{}. In
simple terms, we index the bags and merge the result and pairs. After the results are
merged we wish to reduce this higher level construct back to a bag. The code for
these operations is as follows.

\input{code/indexedEquijoin}

\noindent
In order to understand the code some naming conventions may be useful to
understand. Preceding $i$s are used to denote indexed or indexing structures,
for instance $if1$ is an `indexing function'. Furthermore, the letter $t$
refers to tables. As with previous functions it operates on two bags and
so the indices in variables refer to which bag the function is referring to.

As discussed above, the first step is to index the bags. This is achieved using
an inline form of the \lstinline[language=Haskell]{indexBy} function whose type
signature can be seen below. The \lstinline[language=Haskell]{indexBy} function
takes a table and a function that can transform the table to a key and indexes
the table by the key. The result of indexing a bag is simply a structure that
associates to each key a bag of the values that share that key. Now, with a pair of indexed tables
\lstinline[language=Haskell]{merge}, whose type signature can be seen below,
combines the two indexed tables to one such that for each key a pair of bags is
associated to it. In order to complete reach a usable structure we must perform
a local Cartesian product (hence the \lstinline[language=Haskell]{fmap cp}) on
each pair of bags to finally reach a single bag per key. Now we have a simple
indexed table again we can reduce it back to a bag using the reduce function
(whose type signature is below). More details on the structures used here can be
found in \fref{chap:database}.

\input{code/indexedEquijoinTypeSignatures}

\chapter{Database implementation}\label{chap:database}
This chapter will describe the implementation of the database system outlined in
\relalg{}. The aims of the chapter are to highlight key implementations of the
algorithms of the paper. The purpose of implementing the structures in the paper
are to benchmark and so a high level pragmatic approach is taken in order to
create a working system that can easily be benchmarked.

The structure of the database management system implemented in this
project is a library based off of the code in
\relalg{}~\cite{RelationalAlgebraByWayOfAdjunctions} especially the appendix.
This chapter describes the code needed to create a fully functioning
system as well as highlights my contributions.

\paragraph{Bags} In order to construct the database system an
implementation of a bag (also known as multiset) data structure is
required. Fleshing out the $Bag$ type is one of the main challenges and
contributions of this project in the area of implementing the database. We
base the bag type off a list as the list allows multiple elements and
define an equality function.

\input{code/bagDefAndEquality.tex}

\noindent
It is worth noting that the equality must be defined in such a way that does not
pay attention to the order of elements in the bag. We first create a helper
function $eq'$ that checks equality on lists $xs$ and $ys$ up to permutation.
Given that $xs$ is not empty we check whether $ys$ is non-empty as otherwise
equality would not be possible. If $ys$ has an element, we split the list into
two parts where the head of $xs$ is the first element of the second half of
$ys$. We can then `remove' that element from $ys$, reconstruct the list and
recursively check equality.

As well as defining equality it is also important create instances of $Monad$,
$Functor$ and $CMonoid$ type classes for the bag type. A bag's status as a functor allows $fmap$s
(the parallel to a projection as seen in \fref{sec:background:dbrep}) to be performed on
them and monad type is important to allow monad comprehensions which was a key
motivating factor for the paper \relalg{}. Details of the implementations for these instances are
left out of this paper as they simplyfollow the structure of using the instances on
the underlying list and translating the results back to a bag. A $CMonoid$ is a new type class
defined to distinguish commutative monoids from regular monoids; commutativity
is important as for a bulk type to allow for aggregation (which we expect from a
bag type) it must form a commutative monoid which it does under the union
operation. To allow for extended functionality and testing other interesting
types were given instances of $CMonoid$s such as $Sum\;k$ and $Product\;k$. Moreover, filter
and union functions for bags must be defined to cover the full extent of
relational algebra but their implementations are omitted as they are either
elementary or have been detailed in \relalg{}.

\paragraph{Pointed set} In order to create an indexed structure we must first
implement structures for a pointed set. The pointed set gives us a `null'
element to use for keys where there are no value present and therefore is vital
to a future indexed structure. The type class for a pointed set suggested in
\relalg{} is given below.

\input{code/pointedSetDef.tex}

\noindent
It is important that our $Bag$ type is a pointed set so that we can index our
database by key, thereby assigning bags to each key value in the relation. An
original modified instance of the $PointedSet$ type class for $Bag$ is given
below. Additionally, an instance for $Maybe$ is given as it is an extremely
useful way to promote any type to a $PointedSet$ and was implemented to help
with testing.

\input{code/commonPointedSetImplementations.tex}

\noindent
The advantage of pattern matching instead of comparing when defining a
$PointedSet$ for $Bag$ is that it does not force $Eq$ on the type in the $Bag$.
This is unlikely to be a problem in the very controlled environment of the
benchmark but I appreciated the more general approach so modified the instance
to allow for this behaviour.

\section{Implementation}
We structure our implementation as a library, usually a file in a \texttt{Data}
module per data structure. We base a lot of the content on an example
implementation given in
\cite{RelationalAlgebraByWayOfAdjunctionsPrototypeImplementation}.
\todo{Write what I contributed}

\subsection{Interface design}
Sharing many similarities with \cite{RelationalAlgebraByWayOfAdjunctions}, there
is a considerable design decision that most functions are uncurried. Although
seeming unintuitive, it follows more strictly the mathematical definitions of
the operations, for instance the Cartesian Product on bags $(\times): \bag{a}
\times \bag{b} \to \bag{\left(a \times b\right)}$.

In an implementation perspective, however, it helps unify many of the other
functions. You will notice that the \mathcodefunc{merge} function in
\cite{RelationalAlgebraByWayOfAdjunctions} has the final type \bag{\left(a \times
    b\right)} and so by writing these other operations to work on pairs allows
greater synergy between the interface. This could easily be allowed using
Haskell's built in functions\cite{Prelude} such as \texttt{uncurry} but I felt
as though it created a clunkier interface.

\subsection{Pointed sets}
This section describes the types that declare instances of the
\texttt{PointedSet} type class.

For testing purposes, the most useful type to declare an instance of
\texttt{PointedSet} was the \texttt{Maybe} type. This fits very well as it can
easily raise any existing type to one with a distinguished element (null),
namely \texttt{Nothing}.

Another key type to declare an instance of \texttt{PointedSet} was the
\texttt{Bag} type. A key design decision here was to define \texttt{isEmpty}
using pattern matching in order to avoid the \texttt{Eq} constraint on the
container type of the Bag (i.e. \texttt{Eq a => Bag a}). This instance is key
for the indexing operation $ix$. The function $ix$ has a type $ix ::
\bag{(k, v)} \to \map{k}{(\bag{v})}$, coupled with the requirement $(\pointed{v})
=> \map{k}{v}$ the necessity of the implementation becomes clear and it is
important to note that when indexing the bag of key-value pairs, if a key has no
value, it is the "null" value for \texttt{Bag} that is used and not for $v$
(given that $v$ is even a \texttt{PointedSet} which is not required).

\subsection{Commutative Monoids}
You will see an implementation of \texttt{CMonoid} which is a `logical'
implementation of a commutative monoid. You will see in
\cite{RelationalAlgebraByWayOfAdjunctions} it is stated that there is no way to
enforce the commutativity of the monoid structure in Haskell and they give an
empty class definition with a comment. I have chosen to also include a
\texttt{CMonoid} type class in the supplied library as I feel it forces anyone
writing future implementations to think about the properties their monoid has.
The commutativity requirement is key for aggregations of tables as implemented
by bags because by definition bags do not have an order and therefore the
outcome of the aggregation should not depend on the internal representation of
the bag as would happen given a non-commutative monoid. 
\todo{Write implementation of CMonoid}

\subsection{Indexed Tables}
\paragraph{Natural Joins} In the implementation given, a natural join is defined
by \todo{Add code and mathematical description here} merging two indexed tables
then applying the raised Cartesian product on them. This translates to a local
Cartesian product on the keys indexed by the table. In \fref{sec:natjoin} we
define the natural join as a join that pairs all common indices, and then it is
clear that our implementation defines all common attributes as the key to the
finite map.

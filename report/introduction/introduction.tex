Databases are vital to modern day society for their ability to structure, sort and query vast amounts of data from any domain, ranging from specialised images of eyes \todo{add citation here} to crystal structure \cite{CambridgeStructuralDatabase}. Of course no one theoretical model of data has surfaced since its conception, with different approaches describing how exactly to hold the data. Examples of such data models include the semi-structured model \cite{DatabaseSystems} and, more relevant to this project, the relational model \cite{RelationalModel} as introduced in \fref{sec:relationalmodel}.

The relational model has rich support for the expression of queries and is by no means not varied across its use. Two examples of its family of query representations are \emph{relational calculus} and \emph{relational algebra} with their various advantages \cite{RelationalCalculus,RelationalModel}. \todo{they are equivalent though?} However, the favoured specification of queries for the authors of \cite{RelationalAlgebraByWayOfAdjunctions} seemed to be list comprehensions, a beautiful feature that ``provide for a concise and expressive notation for writing list-processing code''. \cite{MonadComprehensions} They eventually propose using GHC's extended list comprehension syntax in a way to help bridge the already close relationship between relational calculus and list comprehensions \cite{GHCListComprehension,ComprehensiveComprehensions}. Such a method is required in order to avoid the significant theoretical performance hit when working with equijoins.

It is widely noted that \emph{joins}, an integral family of operations in relational algebra, are associated with inefficient implementations \cite{JoinProcessing}. This is clear to see in the generalised case but in their paper \cite{RelationalAlgebraByWayOfAdjunctions} the authors concern themselves with equijoins, a specialised \emph{theta-join} that allows you to combine two relations depending on their attributes (as further described in \fref{sec:joins}); an equijoin simply matches records whose given attribute are equal. An integral part to the calculation of a theta-join is calculating the Cartesian product (all possible combinations of tuples of both relationships, as described in \fref{sec:products}). The algorithm must then filter this bloated collection of tuples by the predicate associated with the theta-join! It is clear that this is wasteful for such an specialised join. As a more practical example consider the SQL program:
\todo{Write Haskell syntax for the above}
\begin{lstlisting}
  SELECT *
  FROM R, S
  WHERE R.a = S.b
\end{lstlisting}
This could be naively converted into a list comprehension with the following:
\[
  \left[\,(r, s)\;|\;r \leftarrow R,\;s \leftarrow S,\;r.a = s.b\,\right]
\]
where $(r, s)$ is seen as a single tuple whose attributes \attribute{\relation{R}.a} and \attribute{\relation{R}.b} are merged. \todo{fix example so that you do not need to see things}

With this naive implementation we effectively convert \equijoin{R}{\attribute{a}}{S}{\attribute{b}} to \select{\attribute{a} = \attribute{b}}{\relation{R} \times \relation{S}}, generating a relation with $|R||S|$ tuples in the process then filtering through each.

This can much be much more efficiently implemented by viewing databases as indexed tables. We can index each relation by its associated attribute in the equijoin and merge the results -- localising the Cartesian product to tuples we know are in the new relation; if care is taken with comparisons and projection, this approach admits a linear time implementation of the equijoin \cite{RelationalAlgebraByWayOfAdjunctions}. With some mathematical tools explained in \fref{sec:gradedmonads} we show that these indexed tables share enough of a monadic structure to fit a comprehension syntax using the extended syntax discussed above.

What this project adds to this story is a concrete demonstration of the improvement this solution offers.
We will use \emph{Haskell} and the list comprehensions and functions described above to implement a simple database querying software taking into account these key changes. Along with real world pragmatic data sources, benchmarking techniques found in \fref{sec:benchmarking} will be used to accurately measure and compare the efficiency difference between the two approaches -- with the new equijoin and without. This evidence would be very important to justify the use of these methods and the claims made in the paper \cite{RelationalAlgebraByWayOfAdjunctions}.
With a concrete implementation, further insights may come to light on the downfall of functional implementation of the remaining operations in the algebra. Using tools such as profiling, clear performance bottlenecks may be identified in order to be studied at a theoretical level in a similar fashion to \cite{RelationalAlgebraByWayOfAdjunctions} over an efficiency-driven optimisation approach.

Similarly, this project also uses similar category theoretical approaches to explore how similar operations are conducted in other domains. We explore what other monadic structures may admit an inefficient list comprehension implementation for common uses. A domain this may be particularly interesting to explore is that of \emph{logic programming}. Questions such as what effect on the underlying logic programs do relational algebraic operations on their model sets have (as many bulk types also admit to a list comprehension syntax by virtue of their monadic structure). Furthermore, if we view normal logic programs themselves as monads, what is the interpretation of the operations above? We also explore whether there is a way to neatly and efficiently implement joins as you might see native in their domains, such as recombining a split program's stable models to find the stable model of the whole system.

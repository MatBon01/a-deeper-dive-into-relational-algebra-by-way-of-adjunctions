\chapter{Introduction}
\begin{comment}
The introduction should summarise the subject area, the specific problem you are addressing, including key ideas for their solution, together with a summary of the project's main contributions. When detailing the contributions it is helpful to provide forward references to the section(s) of the report that provide the relevant technical details. The introduction should be aimed at an informed, but otherwise non-expert, reader. A good tip is to assume that all your assessors will read the abstract and introduction, whereas the more detailed technical sections may only be read by your first and second markers - it's therefore really important to get it right.
\end{comment}

This project is follows the consequences of new techniques to optimise
relational queries of joins followed by selections in Haskell. Say you have the
following records in Haskell.

\input{code/introRecordExample.tex}

\noindent
How might you join two bags of these records together by id? One way would be to
write the following.

\[\lbag\:(s, g)\:|\:s \leftarrow students,\:g \leftarrow grades,\:uid\;s == cid\;g
\:\rbag\]

What are the disadvantages of this approach? Clearly, every possible pair of
elements are considered regardless of whether they have matching ids or not.
This clearly has an asymptotic complexity of $O(nm)$ where $n$ and $m$ are the
cardinality of the $students$ and $grades$ bags respectively.

Databases are vital to modern day society for their ability to structure, sort
and query vast amounts of data from any domain. Of course no one theoretical
model of data has surfaced since its conception, with different approaches
describing how exactly to hold the data. Examples of such data models include
the semi-structured model~\cite{DatabaseSystems} and, more relevant to this
project, the relational model~\cite{RelationalModel} as introduced in
\fref{sec:relationalmodel}. However, all implementations face trade-offs and
development challenges.

This project explores one such solution to the optimisation of queries
consisting of products followed by selections in the relational model. Such
behaviour can be modelled by equijoins, the type of join seen in the example
above, where you wish to keep only two records who share a common attribute.
This project will implement a functioning database system in Haskell according
to the solution outlined in the paper
\relalg{}~\cite{RelationalAlgebraByWayOfAdjunctions}. It then describes original
tools and workflows created to help the benchmarking and testing of the system
in order to evaluate its performance.

Going back to the example, say you could instead index both tables by their
$uid$ and $cid$ respectively. You would not need to consider all possible pair
of elements to find the matching pairs anymore as you would already know which
tuples share the same indexed element. This will allow you to greatly reduce the
order at which you are taking products and, in effect, `making more work for
yourself'. How might this be achieved? The authors of the paper \relalg{},
seemingly enchanted by the elegance of a comprehension notation, have outlined a
category theoretical framework to interpret relational algebra. They found that
many bulk types, such as the bags above, could be made by the adjunction of two
functors and therefore granted them the properties of monads. Moreover, monad
comprehensions have been known about for a substantial amount of
time~\cite{MonadComprehensions} and are generalisation of the expressive list
comprehensions. Therefore, in conjunction with the SQL-like syntax extensions
available to list comprehensions~\cite{ComprehensiveComprehensions} it is hoped
that the defined framework defined in the paper for efficient equijoin can be
expressed in the same concise and powerful manner as the example above.
